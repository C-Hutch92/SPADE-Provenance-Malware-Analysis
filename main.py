import Neo4j_Setup
import Neo4j_Queries as Neo
import LOFModel
import GraphFilteringFuncs
import SentenceEmbedding
import numpy as np
import GraphHelper
import Examples
import tqdm

driver_attack = Neo.MyDriver("bolt://localhost:7687", "neo4j", "s")
driver_benign = Neo.MyDriver("bolt://localhost:8687", "neo4j", "s")

def Full_Example():
    paths_attack_list = []
    paths_benign_list = []

    #Execute a query on both graphs.
    print("Running Neo4j Queries...")
    paths_attack_list, paths_benign_list = Examples.get_paths_start_socket_contains_10_9_address(driver_attack, driver_benign, paths_attack_list, paths_benign_list)
    ### More Example functions can follow, paths are stacked in a list.

    #END OF QUERYING, Closing Connections
    print("Closing Neo4j Connection...")
    driver_attack.close()
    driver_benign.close()

    #Check path timings and delete the END_NODE relationship for malicious and benign graphs
    print("Checking Path Timings and Deleting the single END_NODE path...")
    paths_attack_list = GraphFilteringFuncs.check_path_timings(paths_attack_list)
    paths_attack_list = GraphFilteringFuncs.delete_end_node_path(paths_attack_list)

    paths_benign_list = GraphFilteringFuncs.check_path_timings(paths_benign_list)
    paths_benign_list = GraphFilteringFuncs.delete_end_node_path(paths_benign_list)

    #construct sentences based on the paths found.
    print("Constructing Sentences...")
    sentences_benign = [SentenceEmbedding.create_sentence_from_path(path) for path in paths_benign_list]
    sentences_attack = [SentenceEmbedding.create_sentence_from_path(path) for path in paths_attack_list]

    #Train the PV-DM model and construct sentence embeddings from paths
    print("Constructing Sentence Embeddings...")
    doc_vec_model = SentenceEmbedding.Model()
    doc_vec_model.train(sentences_benign)

    #Infer
    x_attack = [doc_vec_model.infer(sentence) for sentence in sentences_attack]
    x_benign = [doc_vec_model.infer(sentence) for sentence in sentences_benign]

    #convert to a numpy array for easier manipulation
    x_attack_array = np.asarray(x_attack)
    x_benign_array = np.asarray(x_benign)

    ## Local Outlier Factor (LOF) MODELLING ##
    print("Training LOF Model and Inferring...")
    model = LOFModel.Create_Model(3)
    LOFModel.Train(model, x_benign_array)
    lof_scores = LOFModel.Pred(model, x_attack_array)
    lof_scores = np.round(lof_scores, 1)

    #Find the sentences which have a LOF score thats lower than a certain threshold
    threshold = -10
    lof_scores_indx_w_thresh = np.nonzero(lof_scores < threshold)
    print("SUCCESS - Results:")
    print("---------------------")
    print("Outlier Sentences:")
    print(np.asarray(sentences_attack)[lof_scores_indx_w_thresh])
    print("---------------------")

    title = "Query_Output_With_Threshold_{}".format(threshold)
    GraphHelper.plot_scatter_with_outlier_indication(GraphHelper.ax_1_1, title, x_benign_array[:, 0], x_benign_array[:, 1], None, threshold)
    GraphHelper.plot_scatter_with_outlier_indication(GraphHelper.ax_1_1, title, x_attack_array[:, 0], x_attack_array[:, 1], lof_scores, threshold)
    GraphHelper.fig1.savefig("{}.png".format(title))

if __name__ == '__main__':
    #The neo4j queries in this project rely on an END_NODE node and END_REL relationship being present in the graph.
    # Run these command to introduce them into your graph database:
    # Neo4j_Setup.neo4j_db_setup("bolt://localhost:8687")
    # Neo4j_Setup.neo4j_db_setup("bolt://localhost:7687")
    #
    # WARNING: THESE COMMANDS WILL WRITE TO YOUR GRAPH DATABASE, ENSURE THAT YOUR GRAPH DATABASE IS BACKED UP BEFORE YOU DO THIS
    # YOU HAVE BEEN WARNED!

    Full_Example()
